%% V2V NARROWBAND CHANNEL SIMULATION - Parrallelism application for speed
clear; close all; clc;
addpath('Functions');
addpath('Functions/Plotting Functions');



%% START A PARLLEL POOL
if isempty(gcp('nocreate'))
    parpool(); 
end



%% PARAMATERES
fprintf('Defining simulation parameters\n');
params.fc = 5.9e9;
params.c = 3e8;
params.Z_0 = 377;
params.R_a = 73.1;
params.PTX = 0.1; 
params.PRX_sens_dBm = -70;
params.PTX_dBm = 10 * log10(params.PTX * 1000);
params.lambda = params.c / params.fc;

M = 10;                     % Maximum number of reflections to consider
w = 20;
L = 10000e3;                % Length of wall in meters
eps_r = 4;                  % Relative permittivity building walls

walls(1).coordinates = [[0, w/2];  [L, w/2]];  walls(1).eps_r = eps_r;
walls(2).coordinates = [[0, -w/2]; [L, -w/2]];  walls(2).eps_r = eps_r;



%% NARROWBAND LOS ANALYSIS
d = 120;
TX_pos = [0, 0];
RX_pos = [d, 0];

% Run ray tracing for LOS path : M = 0
[~, LOS_rays_data] = runRayTracing(walls, 0, TX_pos, RX_pos, params);
fprintf('\nPerforming LOS analysis for d = %.1fm \n', d);

if ~isempty(LOS_rays_data)
    LOS_ray = LOS_rays_data{1};
    LOS_delay = LOS_ray.distance_total / params.c;
    h_nb_LOS = LOS_ray.alpha_n;
    
    % Calculate received power using the channel transfer function
    PRX_LOS = params.PTX * abs(h_nb_LOS)^2;
    PRX_LOS_dBm = 10 * log10(PRX_LOS * 1000);
    
    fprintf('   - For d = %.1fm:\n', d);
    fprintf('      tau_LOS = %.3es\n', LOS_delay);
    fprintf('      Narrowband Gain |h_NB| = %.3e, Angle = %.2f°\n', abs(h_nb_LOS), rad2deg(angle(h_nb_LOS)));
    fprintf('      Received Power (LOS): %.2fdBm (should match Friis formula)\n', PRX_LOS_dBm);
else
    fprintf('   - No LOS path found for d = %.1fm.\n', d);
end



%% NARROWBAND PRX vs Distance and K-factor
fprintf('\nPerforming full multipath channel analysis\n');

% Analyze MPCs for one distance
fprintf('   - Analyzing MPCs for d = %.1fm\n', d);
[all_alphas, all_rays] = runRayTracing(walls, M, TX_pos, RX_pos, params);

% Plot the ray paths for the distance
fprintf('   - Plotting ray-tracing visualization\n');
plotRays(walls, TX_pos, RX_pos, all_rays, M);

% Display properties of each found ray
for i = 1:length(all_rays)
    ray = all_rays{i};
    fprintf('      Ray %2d: Type = %-7s          d_%d = %7.2fm          |alpha_%d| = %.4e         arg(alpha_%2d) = %7.2f° \n', ... 
        i, ray.type, i, ray.distance_total, i, abs(ray.alpha_n), i, rad2deg(angle(ray.alpha_n)));
end

% Calculate total received power from all paths
h_nb_total = sum(all_alphas);
PRX_total = params.PTX * abs(h_nb_total)^2;
PRX_total_dBm = 10 * log10(PRX_total * 1000);
fprintf('\n   - Total Narrowband Gain at %.1fm: |h_NB| = %.3e\n', d, abs(h_nb_total));
fprintf('   - Total Received Power at %.1fm: PRX = %.2fdBm\n\n', d, PRX_total_dBm);

% Simulate over a range of distances
fprintf('   - Simulating over distances\n');
distances_domain = logspace(0, log10(L), 50000); % points from 1m to 10^
num_distances = length(distances_domain);
PRX_LOS_dBm_domain = zeros(1, num_distances);
PRX_total_dBm_domain = zeros(1, num_distances);
K_factor_dB_domain = zeros(1, num_distances);

queue_1 = parallel.pool.DataQueue;
waitbar_1 = waitbar(0, 'P_{RX} vs. Distance');
set(waitbar_1, 'UserData', 0);
afterEach(queue_1, @(~) updateWaitbar(waitbar_1, num_distances, 'P_{RX} vs. Distance'));

tic;
parfor i = 1:num_distances
    d_loop = distances_domain(i);
    current_tx_pos = [0, 0];
    current_RX_pos = [d_loop, 0];
    [alphas, rays] = runRayTracing(walls, M, current_tx_pos, current_RX_pos, params);
    if isempty(alphas)
        PRX_total_dBm_domain(i) = -Inf;
        PRX_LOS_dBm_domain(i) = -Inf;
        K_factor_dB_domain(i) = -Inf;
        send(queue_1, 1);
        continue;
    end

    % Calculate total power
    h_nb = sum(alphas);
    PRX_total = params.PTX * abs(h_nb)^2;
    PRX_total_dBm_domain(i) = 10 * log10(PRX_total * 1000);
    
    % Separate LOS and NLOS power for K-factor calculation
    alpha_LOS = 0;
    P_NLOS = 0;
    for j = 1:length(rays)
        if strcmp(rays{j}.type, 'LOS') % If type is LOS
            alpha_LOS = rays{j}.alpha_n;
        else
            P_NLOS = P_NLOS + params.PTX * abs(rays{j}.alpha_n)^2;
        end
    end
    P_LOS = params.PTX * abs(alpha_LOS)^2;
    PRX_LOS_dBm_domain(i) = 10 * log10(P_LOS * 1000);
    if P_NLOS > 0
        K_factor = P_LOS / P_NLOS;
        K_factor_dB_domain(i) = 10 * log10(K_factor);
    else
        K_factor_dB_domain(i) = Inf; % Pure LOS case
    end
    send(queue_1, 1);
end
fprintf('      PRX vs Distance simulation took %.2f seconds.\n', toc);

% Cleanup waitbar
if exist('waitbar_1', 'var') && ishandle(waitbar_1)
    close(waitbar_1);
end

fprintf('      Data computation complete.\n\n');

% Plotting Results
fprintf('   - Plotting results\n');
plotPRXvsDistance(distances_domain, PRX_total_dBm_domain, PRX_LOS_dBm_domain);
plotPRXvsPTX()
plotKFactor(distances_domain, K_factor_dB_domain);
% [n_pl, sigma_L, PL_d0] = pathLoss(distances_domain, PRX_total_dBm_domain, params);
% fprintf('     - Calculated Path Loss Exponent n = %.2f\n', n_pl);
% fprintf('     - Shadowing Standard Deviation sigma_L = %.2f dB\n', sigma_L);
% plotCellRangeAnalysis(distances_domain, n_pl, PL_d0, sigma_L, params);



%% PRX vs PTX ANALYSIS
fprintf('\nAnalyzing Received Power vs. Transmitted Power\n');
% 1. Set a fixed distance between Tx and Rx
d_fixed = 150; % meters
TX_pos_fixed = [0, 0];
RX_pos_fixed = [d_fixed, 0];
fprintf('   - Simulating for a fixed distance d = %.1fm\n', d_fixed);
% 2. Calculate the channel transfer function (h_nb) just once for this fixed geometry.
% This is efficient as the channel itself doesn't change with transmit power.
[alphas_fixed, rays_fixed] = runRayTracing(walls, M, TX_pos_fixed, RX_pos_fixed, params);
% Calculate the total channel transfer function from all paths
h_nb_total_fixed = sum(alphas_fixed);
% Find the LOS-only channel transfer function
alpha_LOS_fixed = 0;
for j = 1:length(rays_fixed)
    if strcmp(rays_fixed{j}.type, 'LOS')
        alpha_LOS_fixed = rays_fixed{j}.alpha_n;
        break; % Exit loop once LOS is found
    end
end
% 3. Define a domain of transmit powers to test
ptx_dbm_domain = -10:1:30; % e.g., from -10 dBm to 30 dBm
num_ptx_points = length(ptx_dbm_domain);
% Pre-allocate arrays to store the results
prx_total_dbm_for_ptx_plot = zeros(1, num_ptx_points);
prx_los_dbm_for_ptx_plot = zeros(1, num_ptx_points);
% 4. Loop over the transmit power domain and calculate Rx power for each
for i = 1:num_ptx_points
    current_ptx_dbm = ptx_dbm_domain(i);
    current_ptx_watts = 10^((current_ptx_dbm - 30) / 10);
    % Calculate total received power
    prx_total_watts = current_ptx_watts * abs(h_nb_total_fixed)^2;
    prx_total_dbm_for_ptx_plot(i) = 10 * log10(prx_total_watts * 1000);
    % Calculate LOS-only received power
    prx_los_watts = current_ptx_watts * abs(alpha_LOS_fixed)^2;
    prx_los_dbm_for_ptx_plot(i) = 10 * log10(prx_los_watts * 1000);
end
% 5. Plot the results
fprintf('   - Plotting PRX vs. PTX\n');
plotPRXvsPTX(ptx_dbm_domain, prx_total_dbm_for_ptx_plot, prx_los_dbm_for_ptx_plot);


%% NARROWBAND HEATMAP
fprintf('\nGenerating 2D coverage heatmap\n');
TX_pos     = [10, 0];

x_start    = -20;
x_end      = 500;

y_start    = -w/2-30;
y_end      = w/2+30;

resolution = 0.5;

fprintf('   - Generating %.1fm x %.1fm grid with %.1fm resolution\n', ...
        (x_end - x_start), (y_end - y_start), resolution);
        
num_x_points = round((x_end - x_start) / resolution) + 1;
num_y_points = round((y_end - y_start) / resolution) + 1;
RX_x_coordinates = linspace(x_start, x_end, num_x_points);
RX_y_coordinates = linspace(y_start, y_end, num_y_points);

% Run Simulation for each point on the grid
PRX_dBm = zeros(num_y_points, num_x_points);
PRX_local_dBm = zeros(num_y_points, num_x_points);
fprintf('      Generating Heatmap Data \n');

% Progress bar setup
queue_2 = parallel.pool.DataQueue;
num_iterations = num_x_points;
waitbar_2 = waitbar(0, 'Initializing');
set(waitbar_2, 'UserData', 0);
afterEach(queue_2, @(~) updateWaitbar(waitbar_2, num_iterations, 'Heatmap'));

tic;
parfor i = 1:num_x_points

    % Create temporary column variables to avoid slicing errors in parfor
    temp_PRX_dBm_col = zeros(num_y_points, 1);
    temp_PRX_local_dBm_col = zeros(num_y_points, 1);
    for j = 1:num_y_points
        RX_pos = [RX_x_coordinates(i), RX_y_coordinates(j)];
        dist_from_tx = norm(RX_pos - TX_pos);
        
        % Avoid calculating at the transmitter's exact location
        if dist_from_tx < resolution
            temp_PRX_dBm_col(j) = NaN;
            temp_PRX_local_dBm_col(j) = NaN;
        else
            [alphas, ~] = runRayTracing(walls, M, TX_pos, RX_pos, params);
            if ~isempty(alphas)

                % Instantaneous Power PRX
                h_nb = sum(alphas);
                PRX = params.PTX * abs(h_nb)^2;
                temp_PRX_dBm_col(j) = 10 * log10(PRX * 1000);
                
                % Local Average Power <PRX>
                power_of_each_path = params.PTX * abs(alphas).^2;
                PRX_local_avgs = sum(power_of_each_path);
                temp_PRX_local_dBm_col(j) = 10 * log10(PRX_local_avgs * 1000);
            else
                temp_PRX_dBm_col(j) = NaN;
                temp_PRX_local_dBm_col(j) = NaN;
            end
        end
    end

    % Assign the entire column at once
    PRX_dBm(:, i) = temp_PRX_dBm_col;
    PRX_local_dBm(:, i) = temp_PRX_local_dBm_col;
    
    % Send a message to the queue to update the progress bar
    if ~isempty(queue_2)
        send(queue_2, 1);
    end
end
fprintf('      Heatmap generation took %.2f seconds.\n', toc);

% Cleanup waitbar
if exist('waitbar_2', 'var') && ishandle(waitbar_2)
    close(waitbar_2);
end

% Plotting Results
fprintf('   - Plotting heatmaps\n');

% Plot Instantaneous Power
figure('Name', 'Instantaneous Power Heatmap', 'NumberTitle', 'off');
plotHeatmap(gca, RX_x_coordinates, RX_y_coordinates, PRX_dBm, TX_pos, walls, params.PRX_sens_dBm);
title('Instantaneous Power $P_{RX}$', 'Interpreter', 'latex');

% Plot Local Average Power
figure('Name', 'Local Average Power Heatmap', 'NumberTitle', 'off');
plotHeatmap(gca, RX_x_coordinates, RX_y_coordinates, PRX_local_dBm, TX_pos, walls, params.PRX_sens_dBm);
title('Local Average Power $<P_{RX}>$', 'Interpreter', 'latex');
fprintf('   analysis complete.\n\n');



%% Function to update the waitbar
function updateWaitbar(h_bar, total_iterations, title_str)
    current_count = get(h_bar, 'UserData') + 1;
    set(h_bar, 'UserData', current_count);
    fraction_done = current_count / total_iterations;
    waitbar(fraction_done, h_bar, sprintf('%s  %.1f%%', title_str, fraction_done * 100));
end