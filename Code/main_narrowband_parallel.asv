%% V2V NARROWBAND CHANNEL SIMULATION - Parrallelism application for speed
clear; close all; clc;
addpath('Functions');
addpath('Functions/Plotting Functions');



%% START A PARLLEL POOL
if isempty(gcp('nocreate'))
    parpool(); 
end



%% PARAMATERES
fprintf('Defining simulation parameters\n');
params.fc = 5.9e9;
params.c = 3e8;
params.Z_0 = 377;
params.R_a = 73.1;
params.PTX = 0.1; 
params.PRX_sens_dBm = -70;
params.PTX_dBm = 10 * log10(params.PTX * 1000);
params.lambda = params.c / params.fc;

PTX = params.PTX;
sens_dBm = params.PRX_sens_dBm;
lambda = params.lambda;

M = 1;                     % Maximum number of reflections to consider
w = 20;
L = 10000e3;                % Length of wall in meters
eps_r = 4;                  % Relative permittivity building walls

walls(1).coordinates = [[0, w/2];  [L, w/2]];  walls(1).eps_r = eps_r;
walls(2).coordinates = [[0, -w/2]; [L, -w/2]];  walls(2).eps_r = eps_r;



%% NARROWBAND LOS ANALYSIS
d = 120;
TX_pos = [0, 0];
RX_pos = [d, 0];

% Run ray tracing for LOS path : M = 0
[~, LOS_rays_data] = runRayTracing(walls, 0, TX_pos, RX_pos, params);
fprintf('\nPerforming LOS analysis for d = %.1fm \n', d);

if ~isempty(LOS_rays_data)
    LOS_ray = LOS_rays_data{1};
    LOS_delay = LOS_ray.distance_total / params.c;
    h_nb_LOS = LOS_ray.alpha_n;
    
    % Calculate received power using the channel transfer function
    PRX_LOS = PTX * abs(h_nb_LOS)^2;
    PRX_LOS_dBm = 10 * log10(PRX_LOS * 1000);
    
    fprintf('   - For d = %.1fm:\n', d);
    fprintf('      * tau_LOS = %.3es\n', LOS_delay);
    fprintf('      * Narrowband Gain |h_NB| = %.3e, Angle = %.2f°\n', abs(h_nb_LOS), rad2deg(angle(h_nb_LOS)));
    fprintf('      * Received Power (LOS): %.2fdBm (should match Friis formula)\n', PRX_LOS_dBm);
else
    fprintf('   - No LOS path found for d = %.1fm.\n', d);
end



%% NARROWBAND PRX vs Distance and K-factor
fprintf('\nPerforming full multipath channel analysis\n');

% Analyze MPCs for one distance
fprintf('   - Analyzing MPCs for d = %.1fm\n', d);
[all_alphas, all_rays] = runRayTracing(walls, M, TX_pos, RX_pos, params);

% Plot the ray paths for the distance
fprintf('   - Plotting ray-tracing visualization\n');
plotRays(walls, TX_pos, RX_pos, all_rays, M);

% Display properties of each found ray
for i = 1:length(all_rays)
    ray = all_rays{i};
    fprintf('      * Ray %2d: Type = %-7s          d_%d = %7.2fm          |alpha_%d| = %.4e         arg(alpha_%2d) = %7.2f° \n', ... 
        i, ray.type, i, ray.distance_total, i, abs(ray.alpha_n), i, rad2deg(angle(ray.alpha_n)));
end

% Calculate total received power from all paths
h_nb_total = sum(all_alphas);
PRX_total = PTX * abs(h_nb_total)^2;
PRX_total_dBm = 10 * log10(PRX_total * 1000);
fprintf('\n   - Total Narrowband Gain at %.1fm: |h_NB| = %.3e\n', d, abs(h_nb_total));
fprintf('   - Total Received Power at %.1fm: PRX = %.2fdBm\n', d, PRX_total_dBm);

% Simulate over a range of distances
fprintf('   - Simulating over distances\n');
distances_domain = logspace(0, log10(L), 50000); % points from 1m to 10^
PRX_LOS_dBm_domain = zeros(1, length(distances_domain));
PRX_total_dBm_domain = zeros(1, length(distances_domain));
K_factor_dB_domain = zeros(1, length(distances_domain));

queue_1 = parallel.pool.DataQueue;
waitbar_1 = waitbar(0, 'P_{RX} vs. Distance');
set(waitbar_1, 'UserData', 0);
afterEach(queue_1, @(~) updateWaitbar(waitbar_1, length(distances_domain), 'P_{RX} vs. Distance'));

tic;
parfor i = 1:length(distances_domain)
    d_loop = distances_domain(i);
    current_tx_pos = [0, 0];
    current_RX_pos = [d_loop, 0];
    [alphas, rays] = runRayTracing(walls, M, current_tx_pos, current_RX_pos, params);
    if isempty(alphas)
        PRX_total_dBm_domain(i) = -Inf;
        PRX_LOS_dBm_domain(i) = -Inf;
        K_factor_dB_domain(i) = -Inf;
        send(queue_1, 1);
        continue;
    end

    % Calculate total power
    h_nb = sum(alphas);
    PRX_total = PTX * abs(h_nb)^2;
    PRX_total_dBm_domain(i) = 10 * log10(PRX_total * 1000);
    
    % Separate LOS and NLOS power for K-factor calculation
    alpha_LOS = 0;
    P_NLOS = 0;
    for j = 1:length(rays)
        if strcmp(rays{j}.type, 'LOS') % If type is LOS
            alpha_LOS = rays{j}.alpha_n;
        else
            P_NLOS = P_NLOS + PTX * abs(rays{j}.alpha_n)^2;
        end
    end
    P_LOS = PTX * abs(alpha_LOS)^2;
    PRX_LOS_dBm_domain(i) = 10 * log10(P_LOS * 1000);
    if P_NLOS > 0
        K_factor = P_LOS / P_NLOS;
        K_factor_dB_domain(i) = 10 * log10(K_factor);
    else
        K_factor_dB_domain(i) = Inf; % Pure LOS case
    end
    send(queue_1, 1);
end
fprintf('      * PRX vs Distance simulation took %.2f seconds.\n', toc);

% Cleanup waitbar
if exist('waitbar_1', 'var') && ishandle(waitbar_1)
    close(waitbar_1);
end

fprintf('      * Data computation complete.\n\n');

% Plotting Results
fprintf('   - Plotting results\n');
plotPRXvsDistance(distances_domain, PRX_total_dBm_domain, PRX_LOS_dBm_domain);
plotKFactor(distances_domain, K_factor_dB_domain);



%% NARROWBAND PRX vs PTX
fprintf('\nAnalyzing Received Power vs. Transmitted Power\n');
d = 1000;
% Set a fixed distance between Tx and Rx
TX_pos = [0, 0];
RX_pos = [d, 0];
fprintf('   - Simulating for a fixed distance d = %.1fm\n', d);

% Calculate the channel transfer function just once for this fixed geometry.
[alphas, rays] = runRayTracing(walls, M, TX_pos, RX_pos, params);

% Calculate the total channel transfer function from all paths
h_nb_total = sum(alphas);

% Find the LOS-only channel transfer function
alpha_LOS = 0;
for j = 1:length(rays)
    if strcmp(rays{j}.type, 'LOS')
        alpha_LOS = rays{j}.alpha_n;
        break; % Exit loop once LOS is found
    end
end

PTX_dBm_domain = -70:1:10; 
PRX_total_dBm_domain = zeros(1, length(PTX_dBm_domain));
PRX_LOS_dBm_domain = zeros(1, length(PTX_dBm_domain));

% Progress bar setup
queue_3 = parallel.pool.DataQueue;
waitbar_3 = waitbar(0, 'P_{RX} vs. P_{TX}');
set(waitbar_3, 'UserData', 0);
afterEach(queue_3, @(~) updateWaitbar(waitbar_3, length(PTX_dBm_domain), 'P_{RX} vs. P_{TX}'));

tic;
% Loop over the transmit power domain and calculate Rx power for each
parfor i = 1:length(PTX_dBm_domain)
    current_PTX_dbm = PTX_dBm_domain(i);
    current_PTX = 10^((current_PTX_dbm - 30) / 10);

    % Calculate total received power
    PRX_total = current_PTX * abs(h_nb_total)^2;
    PRX_total_dBm_domain(i) = 10 * log10(PRX_total * 1000);

    % Calculate LOS-only received power
    PRX_los = current_PTX * abs(alpha_LOS)^2;
    PRX_LOS_dBm_domain(i) = 10 * log10(PRX_los * 1000);
    send(queue_3, 1);
end
fprintf('      * PRX vs PTX simulation took %.2f seconds.\n', toc);

% Cleanup waitbar
if exist('waitbar_3', 'var') && ishandle(waitbar_3)
    close(waitbar_3);
end

% Plot the results
fprintf('   - Plotting PRX vs. PTX\n');
plotPRXvsPTX(PTX_dBm_domain, PRX_total_dBm_domain, PRX_LOS_dBm_domain);



%% NARROWBAND HEATMAP
fprintf('\nGenerating 2D coverage heatmap and local averages\n');
TX_pos     = [10, 0];
x_start    = -20;
x_end      = 500;
y_start    = -w/2-30;
y_end      = w/2+30;
d_samp     = 0.5;
d_local = 5.0;  % Cannot be smaller than d_samp

fprintf('   - Generating %.1fm x %.1fm grid with %.1fm sampling interval\n', ...
        (x_end - x_start), (y_end - y_start), d_samp);
        
num_x_points = round((x_end - x_start) / d_samp) + 1;
num_y_points = round((y_end - y_start) / d_samp) + 1;
RX_x_coordinates = linspace(x_start, x_end, num_x_points);
RX_y_coordinates = linspace(y_start, y_end, num_y_points);

% Run Simulation for each point on the grid
PRX_dBm = zeros(num_y_points, num_x_points);
PRX_avg_dBm = zeros(num_y_points, num_x_points);

fprintf('      * Generating Heatmap and Averaged Power Data \n');
% Progress bar setup
queue_2 = parallel.pool.DataQueue;
num_iterations = num_x_points;
waitbar_2 = waitbar(0, '2D Heatmap');
set(waitbar_2, 'UserData', 0);
afterEach(queue_2, @(~) updateWaitbar(waitbar_2, num_iterations, '2D Heatmap'));
tic;

parfor i = 1:num_x_points
    % Create temporary column variables to avoid slicing errors in parfor
    temp_PRX_dBm_col = zeros(num_y_points, 1);
    temp_PRX_avg_dBm_col = zeros(num_y_points, 1);

    for j = 1:num_y_points
        RX_pos = [RX_x_coordinates(i), RX_y_coordinates(j)];
        dist = norm(RX_pos - TX_pos);
        
        % Avoid calculating at the transmitter's exact location
        if dist < d_samp
            temp_PRX_dBm_col(j) = NaN;
            temp_PRX_avg_dBm_col(j) = NaN;
            continue;
        end

        % Calculation of <PRX> over a d_local x d_local area
        num_samples_local = round(d_local / d_samp);
        
        % Define the sample points for the 2D local area
        local_x = linspace(RX_pos(1) - d_local/2, RX_pos(1) + d_local/2, num_samples_local);
        local_y = linspace(RX_pos(2) - d_local/2, RX_pos(2) + d_local/2, num_samples_local);
        
        % Use a 2D matrix to store powers for the 2D local area
        PRX_matrix = zeros(num_samples_local, num_samples_local);
        
        for k = 1:num_samples_local
            for l = 1:num_samples_local
                RX_pos_local = [local_x(k), local_y(l)];
                
                % Run ray tracing for this sample point
                [alphas_local, ~] = runRayTracing(walls, M, TX_pos, RX_pos_local, params);
                
                % calculate power if rays are found
                if ~isempty(alphas_local)
                    h_nb_local = sum(alphas_local);
                    PRX_matrix(l, k) = PTX * abs(h_nb_local)^2;
                else
                    PRX_matrix(l, k) = 0;
                end
            end
        end
        
        % Calculate the average power <PRX> over the 2D area
        PRX_avg = mean(PRX_matrix(:));
        
        % Store the instantaneous power at the center point for the heatmap
        local_center = round(num_samples_local / 2);
        PRX = PRX_matrix(local_center, local_center);
        
        % Store the instaneous power
        if PRX > 0 % Health check
            temp_PRX_dBm_col(j) = 10 * log10(PRX * 1000);
        else
            temp_PRX_dBm_col(j) = -Inf;
        end
        
        % Store the averaged power
        if PRX_avg > 0 % Health check
            temp_PRX_avg_dBm_col(j) = 10 * log10(PRX_avg * 1000);
        else
            temp_PRX_avg_dBm_col(j) = -Inf;
        end
    end
    
    % Assign the entire columns at once
    PRX_dBm(:, i) = temp_PRX_dBm_col;
    PRX_avg_dBm(:, i) = temp_PRX_avg_dBm_col;
    
    % Send a message to the queue to update the progress bar
    if ~isempty(queue_2)
        send(queue_2, 1);
    end
end

fprintf('      * Data generation took %.2f seconds.\n', toc);

% Cleanup waitbar
if exist('waitbar_2', 'var') && ishandle(waitbar_2)
    close(waitbar_2);
end

% Plotting Results
fprintf('   - Plotting heatmaps\n');

% Plot Instantaneous Power
figure('Name', 'Instantaneous Power Heatmap', 'NumberTitle', 'off');
plotHeatmap(gca, RX_x_coordinates, RX_y_coordinates, PRX_dBm, TX_pos, walls, sens_dBm);
title('Instantaneous Power $P_{RX}$', 'Interpreter', 'latex');

% Plot Averaged Power
% Trick to make the heatmap display well
walls(1).coordinates = walls(1).coordinates + d_local/2 * [[1  1]; [1  1]];
walls(2).coordinates = walls(2).coordinates + d_local/2 * [[1 -1]; [1 -1]];

figure('Name', 'Averaged Power Heatmap', 'NumberTitle', 'off');
plotHeatmap(gca, RX_x_coordinates, RX_y_coordinates, PRX_avg_dBm, TX_pos, walls, sens_dBm);
title('Averaged Power $\langle P_{RX} \rangle$', 'Interpreter', 'latex');



%% Function to update the waitbar
function updateWaitbar(h_bar, total_iterations, title_str)
    current_count = get(h_bar, 'UserData') + 1;
    set(h_bar, 'UserData', current_count);
    fraction_done = current_count / total_iterations;
    waitbar(fraction_done, h_bar, sprintf('%s  %.1f%%', title_str, fraction_done * 100));
end
