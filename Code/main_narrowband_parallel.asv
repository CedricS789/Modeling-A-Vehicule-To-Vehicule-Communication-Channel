%% V2V NARROWBAND CHANNEL SIMULATION
clear; close all; clc;
addpath('Functions');
addpath('Functions/Plotting Functions');



%% START A PARLLEL POOL
if isempty(gcp('nocreate'))
    parpool(); 
end



%% PARAMATERES
fprintf('Defining simulation parameters\n');
params.fc = 5.9e9;
params.c = 3e8;
params.Z_0 = 377;
params.R_a = 73.1;
params.P_TX = 0.1; 
params.P_RX_sens_dBm = -70;
params.P_TX_dBm = 10 * log10(params.P_TX * 1000);
params.lambda = params.c / params.fc;

M = 1;                      % Maximum number of reflections to consider
w = 20;
L = 10000e3;                   % Length of wall in meters
eps_r = 4;                  % Relative permittivity building walls
walls(1).coordinates = [[0, w/2]; [L, w/2]];    walls(1).eps_r = eps_r;
walls(2).coordinates = [[0, -w/2]; [L, -w/2]];  walls(2).eps_r = eps_r;



%% NARROWBAND LOS ANALYSIS
d = 150;
tx_pos = [0, 0];
RX_pos = [d, 0];

% Run ray tracing for LOS path : M = 0
[~, LOS_rays_data] = runRayTracing(walls, 0, tx_pos, RX_pos, params);
fprintf('\nPerforming LOS analysis for d = %.1fm \n', d);

if ~isempty(LOS_rays_data)
    LOS_ray = LOS_rays_data{1};
    LOS_delay = LOS_ray.distance_total / params.c;
    h_nb_LOS = LOS_ray.alpha_n;
    
    % Calculate received power using the channel transfer function
    P_RX_LOS = params.P_TX * abs(h_nb_LOS)^2;
    P_RX_LOS_dBm = 10 * log10(P_RX_LOS * 1000);
    
    fprintf('   - For d = %.1fm:\n', d);
    fprintf('      tau_LOS = %.3es\n', LOS_delay);
    fprintf('      Narrowband Gain |h_NB| = %.3e, Angle = %.2f°\n', abs(h_nb_LOS), rad2deg(angle(h_nb_LOS)));
    fprintf('      Received Power (LOS): %.2fdBm (should match Friis formula)\n', P_RX_LOS_dBm);
else
    fprintf('   - No LOS path found for d = %.1fm.\n', d);
end



%% NARROWBAND FULL MULTIPATH CHANNEL ANALYSIS
fprintf('\nPerforming full multipath channel analysis\n');

% Analyze MPCs for one distance
fprintf('   - Analyzing MPCs for d = %.1fm\n', d);
[all_alphas, all_rays] = runRayTracing(walls, M, tx_pos, RX_pos, params);

% Plot the ray paths for the distance
fprintf('   - Plotting ray-tracing visualization\n\n');
plotRays(walls, tx_pos, RX_pos, all_rays, M); xlim([tx_pos(1)-10, RX_pos(1)+10]); ylim([-w/2-2, w/2+2]);

% Display properties of each found ray
for i = 1:length(all_rays)
    ray = all_rays{i};
    fprintf('      Ray %2d: Type = %-7s          d_%d  = %7.2fm          |alpha_%d| = %.4e         arg(alpha_%2d) = %7.2f° \n', ... 
        i, ray.type, i, ray.distance_total, i, abs(ray.alpha_n), i, rad2deg(angle(ray.alpha_n)));
end

% Calculate total received power from all paths
h_nb_total = sum(all_alphas);
P_RX_total = params.P_TX * abs(h_nb_total)^2;
P_RX_total_dBm = 10 * log10(P_RX_total * 1000);
fprintf('\n   - Total Narrowband Gain at %.1fm: |h_NB| = %.3e\n', d, abs(h_nb_total));
fprintf('   - Total Received Power at %.1fm: P_RX = %.2fdBm\n\n', d, P_RX_total_dBm);

% Simulate over a range of distances
fprintf('   - Simulating over distances\n');
distances_domain = logspace(0, log10(L), 5000); % points from 1m to 10^
num_distances = length(distances_domain);
P_RX_LOS_dBm_domain = zeros(1, num_distances);
P_RX_total_dBm_domain = zeros(1, num_distances);
K_factor_dB_domain = zeros(1, num_distances);

queue_1 = parallel.pool.DataQueue;
waitbar_1 = waitbar(0, 'P_{RX} vs. Distance');
set(waitbar_1, 'UserData', 0);
afterEach(queue_1, @(~) updateWaitbar(waitbar_1, num_distances, 'P_{RX} vs. Distance'));

tic;
parfor i = 1:num_distances
    d_loop = distances_domain(i);
    current_tx_pos = [0, 0];
    current_RX_pos = [d_loop, 0];
    [alphas, rays] = runRayTracing(walls, M, current_tx_pos, current_RX_pos, params);
    if isempty(alphas)
        P_RX_total_dBm_domain(i) = -Inf;
        P_RX_LOS_dBm_domain(i) = -Inf;
        K_factor_dB_domain(i) = -Inf;
        send(queue_1, 1);
        continue;
    end

    % Calculate total power
    h_nb = sum(alphas);
    P_RX_total = params.P_TX * abs(h_nb)^2;
    P_RX_total_dBm_domain(i) = 10 * log10(P_RX_total * 1000);
    
    % Separate LOS and NLOS power for K-factor calculation
    alpha_LOS = 0;
    P_NLOS = 0;
    for j = 1:length(rays)
        if strcmp(rays{j}.type, 'LOS') % If type is LOS
            alpha_LOS = rays{j}.alpha_n;
        else
            P_NLOS = P_NLOS + params.P_TX * abs(rays{j}.alpha_n)^2;
        end
    end
    P_LOS = params.P_TX * abs(alpha_LOS)^2;
    P_RX_LOS_dBm_domain(i) = 10 * log10(P_LOS * 1000);
    if P_NLOS > 0
        K_factor = P_LOS / P_NLOS;
        K_factor_dB_domain(i) = 10 * log10(K_factor);
    else
        K_factor_dB_domain(i) = Inf; % Pure LOS case
    end
    send(queue_1, 1);
end
fprintf('      P_RX vs Distance simulation took %.2f seconds.\n', toc);

% Cleanup waitbar
if exist('waitbar_1', 'var') && ishandle(waitbar_1)
    close(waitbar_1);
end

fprintf('      Data computation complete.\n\n');

% Plotting Results
fprintf('   - Plotting results\n');
plotReceivedPower(distances_domain, P_RX_total_dBm_domain, P_RX_LOS_dBm_domain);
% plotKFactor(distances_domain, K_factor_dB_domain);
% [n_pl, sigma_L, PL_d0] = pathLoss(distances_domain, P_RX_total_dBm_domain, params);
% fprintf('     - Calculated Path Loss Exponent n = %.2f\n', n_pl);
% fprintf('     - Shadowing Standard Deviation sigma_L = %.2f dB\n', sigma_L);
% plotCellRangeAnalysis(distances_domain, n_pl, PL_d0, sigma_L, params);



%% NARROWBAND HEATMAP
fprintf('\nGenerating 2D coverage heatmap\n');
tx_pos     = [10, 0];
x_start    = -20;
x_end      = 1000;
y_start    = -w/2-20;
y_end      = w/2+20;
resolution = 10;
fprintf('   - Generating %.1fm x %.1fm grid with %.1fm resolution\n', ...
        (x_end - x_start), (y_end - y_start), resolution);
        
num_x_points = round((x_end - x_start) / resolution) + 1;
num_y_points = round((y_end - y_start) / resolution) + 1;
RX_x_coordinates = linspace(x_start, x_end, num_x_points);
RX_y_coordinates = linspace(y_start, y_end, num_y_points);

% Run Simulation for each point on the grid
P_RX_dBm = zeros(num_y_points, num_x_points);
P_RX_local_dBm = zeros(num_y_points, num_x_points);
fprintf('      Generating Heatmap Data \n');

% Progress bar setup
queue_2 = parallel.pool.DataQueue;
num_iterations = num_x_points;
waitbar_2 = waitbar(0, 'Initializing');
set(waitbar_2, 'UserData', 0);
afterEach(queue_2, @(~) updateWaitbar(waitbar_2, num_iterations, 'Heatmap'));

tic;
parfor i = 1:num_x_points

    % Create temporary column variables to avoid slicing errors in parfor
    temp_P_RX_dBm_col = zeros(num_y_points, 1);
    temp_P_RX_local_dBm_col = zeros(num_y_points, 1);
    for j = 1:num_y_points
        RX_pos = [RX_x_coordinates(i), RX_y_coordinates(j)];
        dist_from_tx = norm(RX_pos - tx_pos);
        
        % Avoid calculating at the transmitter's exact location
        if dist_from_tx < resolution
            temp_P_RX_dBm_col(j) = NaN;
            temp_P_RX_local_dBm_col(j) = NaN;
        else
            [alphas, ~] = runRayTracing(walls, M, tx_pos, RX_pos, params);
            if ~isempty(alphas)

                % Instantaneous Power P_RX
                h_nb = sum(alphas);
                P_RX = params.P_TX * abs(h_nb)^2;
                temp_P_RX_dBm_col(j) = 10 * log10(P_RX * 1000);
                
                % Local Average Power <P_RX>
                power_of_each_path = params.P_TX * abs(alphas).^2;
                P_RX_local_avgs = sum(power_of_each_path);
                temp_P_RX_local_dBm_col(j) = 10 * log10(P_RX_local_avgs * 1000);
            else
                temp_P_RX_dBm_col(j) = NaN;
                temp_P_RX_local_dBm_col(j) = NaN;
            end
        end
    end

    % Assign the entire column at once
    P_RX_dBm(:, i) = temp_P_RX_dBm_col;
    P_RX_local_dBm(:, i) = temp_P_RX_local_dBm_col;
    
    % Send a message to the queue to update the progress bar
    if ~isempty(queue_2)
        send(queue_2, 1);
    end
end
fprintf('      Heatmap generation took %.2f seconds.\n', toc);

% Cleanup waitbar
if exist('waitbar_2', 'var') && ishandle(waitbar_2)
    close(waitbar_2);
end

% Plotting Results
fprintf('   - Plotting heatmaps\n');
figure('Name', 'Power Heatmap Comparison', 'NumberTitle', 'off', 'Position', [50, 200, 1800, 400]);

% Plot Instantaneous Power
% ax1 = subplot(2, 1, 1);
ax1 = gca;
figure('Name', 'Local Average Power (<P_RX>)', 'NumberTitle', 'off', 'Position', [960, 400, 900, 450]);
plotHeatmap(ax1, RX_x_coordinates, RX_y_coordinates, P_RX_dBm, tx_pos, walls, params.P_RX_sens_dBm);
title('Instantaneous Power (P_{RX})', 'Interpreter', 'latex');

% Plot Local Average Power
% ax2 = subplot(2, 1, 2);
ax1 = gca;

figure('Name', 'Local Average Power (<P_RX>)', 'NumberTitle', 'off', 'Position', [960, 400, 900, 450]);
plotHeatmap(ax2, RX_x_coordinates, RX_y_coordinates, P_RX_local_dBm, tx_pos, walls, params.P_RX_sens_dBm);
title('Local Average Power (<P_{RX}>)', 'Interpreter', 'latex');
fprintf('   analysis complete.\n\n');


%% Function to update the waitbar
function updateWaitbar(h_bar, total_iterations, title_str)
    current_count = get(h_bar, 'UserData') + 1;
    set(h_bar, 'UserData', current_count);
    fraction_done = current_count / total_iterations;
    waitbar(fraction_done, h_bar, sprintf('%s  %.1f%%', title_str, fraction_done * 100));
end